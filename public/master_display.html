<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>è€äººç«¯ï¼šSupporter-Agentï¼ˆé˜¶æ®µéš”ç¦»ç‰ˆï¼‰</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#F8FAFC; margin:0; display:flex; height:100vh; color:#0F172A; }
    #sidebar { width:320px; background:#fff; border-right:1px solid #E2E8F0; padding:18px; box-sizing:border-box; overflow:auto; }
    #main { flex:1; display:flex; flex-direction:column; padding:18px; box-sizing:border-box; gap:12px; min-width:0; }
    .btn { background:#A78BFA; color:#fff; border:none; padding:10px 12px; border-radius:10px; cursor:pointer; font-size:15px; width:100%; }
    .btn.dark { background:#1E293B; }
    .btn.ghost { background:#fff; color:#0F172A; border:1px solid #E2E8F0; }
    .muted { color:#64748B; font-size:13px; }
    .row { display:flex; gap:10px; }
    .pill { padding:6px 10px; border-radius:999px; background:#E2E8F0; cursor:pointer; user-select:none; font-size:14px; }
    .pill.active { background:#A78BFA; color:#fff; }
    .card { background:#fff; border:1px solid #E2E8F0; border-radius:16px; box-shadow: 0 4px 10px -6px rgba(0,0,0,.12); }
    /* critical: allow chat area to scroll inside flex column */
    section.card { min-height:0; }
    #chat { flex:1; padding:16px; overflow:auto; min-height:0; }
    .msg { display:flex; margin:10px 0; }
    .msg.right { justify-content:flex-end; }
    .bubble { max-width:75%; padding:10px 12px; border-radius:14px; line-height:1.5; font-size:15px; }
    .bubble.user { background:#A78BFA; color:#fff; border-bottom-right-radius:6px; }
    .bubble.other { background:#F1F5F9; color:#0F172A; border-bottom-left-radius:6px; }
    .meta { font-size:12px; opacity:.85; margin-bottom:4px; display:flex; gap:8px; align-items:center; }
    .meta .time { opacity:.85; }
    #composer { display:flex; gap:10px; align-items:center; padding:12px; }
    #input { flex:1; padding:10px 12px; border:1px solid #E2E8F0; border-radius:12px; font-size:15px; outline:none; }
    .wave-box { height:66px; border-radius:40px; background:#F1F5F9; border:1px solid #E2E8F0; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .wave-bar { width:92%; height:34px; border-radius:20px; background: linear-gradient(90deg, #A78BFA, #C084FC, #A78BFA); transform: scaleY(.35); transition: transform .08s ease-out; }
    .session-item { padding:10px 10px; border-radius:12px; cursor:pointer; border:1px solid transparent; }
    .session-item:hover { background:#F8FAFC; border-color:#E2E8F0; }
    .session-item.active { background:#EEF2FF; border-color:#C7D2FE; }
    .divider { height:1px; background:#E2E8F0; margin:12px 0; }
    code { background:#F1F5F9; padding:1px 6px; border-radius:8px; }
    #micBanner { display:none; margin-top:10px; padding:10px 12px; border:1px solid #FDE68A; background:#FFFBEB; border-radius:12px; color:#92400E; }
  </style>
</head>
<body>
  <aside id="sidebar">
    <div class="row">
      <button class="btn" id="btnNew">â• å¼€å¯æ–°è®¨è®º</button>
    </div>

    <div id="micBanner">
      éœ€è¦å¯ç”¨éº¦å…‹é£æ‰èƒ½è¿›è¡Œå®æ—¶è½¬å½•ã€‚
      <div style="margin-top:8px">
        <button class="btn" id="btnEnableMic">ç‚¹å‡»å¯ç”¨éº¦å…‹é£</button>
      </div>
    </div>

    <div style="margin-top:10px" class="muted">
      é‡‡é›†ç«¯åŠ å…¥é“¾æ¥ï¼ˆå•è®¾å¤‡åŒå£°é“ï¼Œä»…â€œè®¨è®ºä¸­â€æ¥æ”¶ï¼‰ï¼š
      <div style="margin-top:6px; line-height:1.6">
        <code id="joinDual"></code>
      </div>
    </div>
    <div class="divider"></div>
    <div style="display:flex; align-items:center; justify-content:space-between">
      <b>ğŸ“œ å†å²ä¼šè¯</b>
      <span class="muted" id="modeBadge"></span>
    </div>
    <div id="sessionList" style="margin-top:10px"></div>
  </aside>

  <main id="main">
    <div class="row" style="gap:8px; align-items:center;">
      <div class="pill" data-phase="preparation">è®¨è®ºå‰</div>
      <div class="pill active" data-phase="discussion">è®¨è®ºä¸­</div>
      <div class="pill" data-phase="review">è®¨è®ºå</div>
      <div style="flex:1"></div>
      <button class="btn ghost" id="btnToggleRecord" style="width:auto">ğŸ¤ æˆæƒé‡‡é›†ç«¯ï¼šå¼€</button>
      <button class="btn" id="btnTalk" style="width:auto" disabled>ğŸ™ï¸ å¼€å§‹æ”¶éŸ³</button>
      <button class="btn dark" id="btnEnd" style="width:auto">ç»“æŸè®¨è®ºå¹¶å­˜æ¡£</button>
    </div>

    <section class="card" style="flex:1; display:flex; flex-direction:column;">
      <div style="display:flex; gap:10px; padding:12px 16px; border-bottom:1px solid #E2E8F0;">
        <div class="muted" id="capL" style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">è¯´è¯äºº1ï¼šâ€¦</div>
        <div class="muted" id="capR" style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; text-align:right;">â€¦ï¼šè¯´è¯äºº2</div>
      </div>

      <div id="chat"></div>

      <div class="divider" style="margin:0"></div>
      <div id="composer">
        <input id="input" placeholder="è€äººè¯´ä¸€å¥â€¦ï¼ˆå›è½¦å‘é€ï¼‰"/>
        <button class="btn" id="btnSend" style="width:auto">å‘é€</button>
      </div>
    </section>

    <div class="muted">ğŸ™ï¸ æ‚¨çš„å£°éŸ³æ˜¾åŒ–ï¼ˆå®æ—¶éŸ³é‡ï¼‰</div>
    <div class="wave-box card"><div id="wave" class="wave-bar"></div></div>
  </main>

<script>
  // ---------- helpers ----------
  const qs = (k) => new URLSearchParams(location.search).get(k);
  const setQS = (k,v) => {
    const u = new URL(location.href);
    if (v === null) u.searchParams.delete(k); else u.searchParams.set(k,v);
    history.replaceState({}, "", u.toString());
  }
  const api = (path, opt={}) => fetch(path, {headers: {"Content-Type":"application/json"}, ...opt});
  const fmtTime = (unix) => {
    if(!unix) return "";
    const d = new Date(unix*1000);
    const pad = n => (n<10?("0"+n):n);
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }
  function escapeHtml(str) {
    return String(str).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;").replaceAll("\n","<br/>");
  }

  // ---------- state ----------
  let sessionId = qs("session_id");
  let phase = qs("phase") || "discussion";        // preparation | discussion | review
  let mode = "live";                               // live | view
  let recordActive = true;
  let ws = null;
  let reconnectTimer = null;

  // phase-isolated message buffers
  const phases = ["preparation", "discussion", "review"];
  const messagesByPhase = { preparation: [], discussion: [], review: [] };
  let lastMsgId = 0;

  // mic upload websocket (elder -> backend as channel E)
  let wsMic = null;
  let audioCtxE = null, mediaStreamE = null, sourceNodeE = null, processorE = null;
  let seqE = 0;
  const targetRateE = 16000;
  let micReady = false;

  let elderStreaming = false; // push-to-talk: only send audio when true
  // ---------- elements ----------
  const elChat = document.getElementById("chat");
  const elInput = document.getElementById("input");
  const elWave = document.getElementById("wave");
  const elList = document.getElementById("sessionList");
  const elModeBadge = document.getElementById("modeBadge");
  const btnNew = document.getElementById("btnNew");
  const btnSend = document.getElementById("btnSend");
  const btnEnd = document.getElementById("btnEnd");
  const btnToggleRecord = document.getElementById("btnToggleRecord");
  const joinDual = document.getElementById("joinDual");
  const capL = document.getElementById("capL");
  const capR = document.getElementById("capR");
  const micBanner = document.getElementById("micBanner");
  const btnEnableMic = document.getElementById("btnEnableMic");

  function renderJoinLinks() {
    const base = `${location.protocol}//${location.host}`;
    joinDual.textContent = `${base}/client_display.html?session_id=${sessionId}`;
  }

  function setMode(newMode) {
    mode = newMode;
    elModeBadge.textContent = (mode === "view") ? "æŸ¥çœ‹æ¨¡å¼" : "å®æ—¶æ¨¡å¼";
    const disabled = (mode === "view");
    elInput.disabled = disabled;
    btnSend.disabled = disabled;
    btnToggleRecord.disabled = disabled;
    btnEnd.disabled = disabled;
    elInput.placeholder = disabled ? "å½“å‰ä¸ºæŸ¥çœ‹æ¨¡å¼ï¼Œç‚¹å‡»â€œå¼€å¯æ–°è®¨è®ºâ€è¿”å›å®æ—¶æ¨¡å¼" : "è€äººè¯´ä¸€å¥â€¦ï¼ˆå›è½¦å‘é€ï¼‰";
    if (mode === "view") {
      stopElderMic();
    } else {
      ensureElderMic();
    }
  }

  function setPhase(p) {
    if (!phases.includes(p)) p = "discussion";
    phase = p;
    setQS("phase", p);
    document.querySelectorAll(".pill").forEach(x => x.classList.toggle("active", x.dataset.phase === p));

    // clear partial captions when leaving discussion
    if (phase !== "discussion") {
      capL.textContent = "è¯´è¯äºº1ï¼šâ€¦";
      capR.textContent = "â€¦ï¼šè¯´è¯äºº2";
    }

    // tell backend current phase (for elder channel routing + client gate)
    if (mode === "live" && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type:"set_phase", phase}));
    }

    // render this phase buffer
    renderPhase(phase);
  }

  document.querySelectorAll(".pill").forEach(p => p.addEventListener("click", () => setPhase(p.dataset.phase)));

  function clearChat() { elChat.innerHTML = ""; }

  function addBubbleToDOM(speaker, content, side, ts) {
    const wrap = document.createElement("div");
    wrap.className = "msg " + (side === "right" ? "right" : "left");
    const bubble = document.createElement("div");
    bubble.className = "bubble " + (side === "right" ? "user" : "other");
    bubble.innerHTML = `<div class="meta"><b>${escapeHtml(speaker || "")}</b><span class="time muted">${escapeHtml(ts||"")}</span></div>${escapeHtml(content)}`;
    wrap.appendChild(bubble);
    elChat.appendChild(wrap);
  }

  function renderPhase(p) {
    clearChat();
    const arr = messagesByPhase[p] || [];
    arr.forEach(m => {
      const side = (m.speaker === "è€äºº") ? "right" : "left";
      addBubbleToDOM(m.speaker, m.content, side, fmtTime(m.ts||0));
    });
    // scroll bottom
    elChat.scrollTop = elChat.scrollHeight;
  }

  function appendMessage(m) {
    // buffer
    const p = phases.includes(m.phase) ? m.phase : "discussion";
    messagesByPhase[p].push(m);
    lastMsgId = Math.max(lastMsgId, m.id || 0);

    // render only if matches current phase
    if (p !== phase) return;

    // smart autoscroll (only if user is near bottom)
    const nearBottom = elChat.scrollTop + elChat.clientHeight >= elChat.scrollHeight - 120;

    const side = (m.speaker === "è€äºº") ? "right" : "left";
    addBubbleToDOM(m.speaker, m.content, side, fmtTime(m.ts||0));

    if (nearBottom) elChat.scrollTop = elChat.scrollHeight;
  }

  // ---------- WebSocket (master) ----------
  function wsUrl() {
    const proto = location.protocol === "https:" ? "wss" : "ws";
    return `${proto}://${location.host}/ws/master?session_id=${encodeURIComponent(sessionId)}`;
  }

  function connectWS() {
    if (mode !== "live") return;
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

    ws = new WebSocket(wsUrl());

    ws.onopen = () => {
      if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
      renderJoinLinks();
      // sync backend phase immediately
      ws.send(JSON.stringify({type:"set_phase", phase}));
      // sync record gate too
      ws.send(JSON.stringify({type:"set_active", active: recordActive}));
      ensureElderMic();
    };

    ws.onmessage = (ev) => {
      const data = JSON.parse(ev.data);

      if (data.type === "ping") {
        ws.send(JSON.stringify({type:"pong", ts: data.ts}));
        return;
      }

      if (data.type === "phase") {
        // server confirmed phase; trust local UI as source of truth, ignore unless mismatch
        return;
      }

      if (data.type === "asr_partial") {
        // Only show client partial captions in discussion
        if ((data.phase || "discussion") !== "discussion") return;
        if (phase !== "discussion") return;
        const ch = (data.channel || "").toUpperCase();
        const t = data.content || "";
        if (ch === "L") capL.textContent = `${data.speaker || "è¯´è¯äºº1"}ï¼š${t}`;
        if (ch === "R") capR.textContent = `${t}ï¼š${data.speaker || "è¯´è¯äºº2"}`;
        return;
      }

      if (data.type === "text") {
        // phase-isolated message
        appendMessage({
          id: data.id || 0,
          phase: data.phase || "discussion",
          speaker: data.speaker || "",
          content: data.content || "",
          ts: data.ts || Math.floor(Date.now()/1000),
        });
        return;
      }

      if (data.type === "volume") {
        // We only use elder volume for the wave. Some servers may send L/R too.
        const ch = (data.channel || "E").toUpperCase();
        if (ch !== "E") return;
        const v = data.value || 0;
        elWave.style.transform = `scaleY(${0.35 + v * 2})`;
        return;
      }
    };

    ws.onclose = () => scheduleReconnect();
    ws.onerror = () => scheduleReconnect();
  }

  function scheduleReconnect() {
    if (mode !== "live") return;
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWS();
    }, 1200);
  }

  // ---------- REST: sessions ----------
  async function refreshSessions() {
    const res = await api("/api/sessions?limit=80");
    const data = await res.json();
    elList.innerHTML = "";
    (data.sessions || []).forEach(s => {
      const div = document.createElement("div");
      div.className = "session-item" + (s.session_id === sessionId && mode==="view" ? " active" : "");
      const title = s.summary_title || "ï¼ˆæœªå‘½åè®¨è®ºï¼‰";
      div.innerHTML = `<div><b>${escapeHtml(title)}</b></div><div class="muted">${escapeHtml(fmtTime(s.created_at))}${s.ended_at ? " Â· å·²å­˜æ¡£" : ""}</div>`;
      div.onclick = () => openHistory(s.session_id);
      elList.appendChild(div);
    });
  }

  function resetPhaseBuffers() {
    phases.forEach(p => messagesByPhase[p] = []);
    lastMsgId = 0;
    renderPhase(phase);
  }

  async function createNewSession() {
    const res = await api("/api/sessions", {method:"POST", body: JSON.stringify({meta:{}})});
    const s = await res.json();
    sessionId = s.session_id;
    setQS("session_id", sessionId);
    setMode("live");
    renderJoinLinks();
    resetPhaseBuffers();
    connectWS();
    // default phase
    setPhase("discussion");
  }

  async function endSession() {
    await api(`/api/sessions/${encodeURIComponent(sessionId)}/end`, {method:"POST", body: JSON.stringify({})});
    await refreshSessions();
    alert("å·²å­˜æ¡£åˆ°å†å²ä¼šè¯ âœ…");
  }

  // ---------- view mode ----------
  async function openHistory(sid) {
    setMode("view");
    if (ws) { try { ws.close(); } catch(e) {} }
    sessionId = sid;
    setQS("session_id", sessionId);
    renderJoinLinks();
    await loadSessionView(sid);
    await refreshSessions();
  }

  async function loadSessionView(sid) {
    resetPhaseBuffers();
    const res = await api(`/api/sessions/${encodeURIComponent(sid)}`);
    const sess = await res.json();
    (sess.messages || []).forEach(m => {
      const p = phases.includes(m.phase) ? m.phase : "discussion";
      messagesByPhase[p].push({
        id: m.id || 0,
        phase: p,
        speaker: m.speaker || "",
        content: m.content || "",
        ts: m.ts || 0
      });
      lastMsgId = Math.max(lastMsgId, m.id || 0);
    });
    renderPhase(phase);
  }

  // ---------- send typed text ----------
  async function sendText() {
    if (mode !== "live") return;
    const text = elInput.value.trim();
    if (!text) return;
    elInput.value = "";
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type:"text", phase, speaker:"è€äºº", content:text}));
    } else {
      await api(`/api/sessions/${encodeURIComponent(sessionId)}/messages`, {method:"POST", body: JSON.stringify({
        phase, role:"user", speaker:"è€äºº", content:text
      })});
      appendMessage({id:0, phase, speaker:"è€äºº", content:text, ts: Math.floor(Date.now()/1000)});
    }
  }

  btnSend.onclick = sendText;
  elInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendText(); });

  btnNew.onclick = async () => { await createNewSession(); };
  btnEnd.onclick = async () => { await endSession(); };

  btnToggleRecord.onclick = () => {
    recordActive = !recordActive;
    btnToggleRecord.textContent = `ğŸ¤ æˆæƒé‡‡é›†ç«¯ï¼š${recordActive ? "å¼€" : "å…³"}`;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type:"set_active", active: recordActive}));
    }
  }

  // ---------- Elder mic capture -> ws/client?channel=E ----------
  function wsMicUrl() {
    const proto = location.protocol === "https:" ? "wss" : "ws";
    return `${proto}://${location.host}/ws/client?session_id=${encodeURIComponent(sessionId)}&channel=E`;
  }

  function floatToPCM16(float32) {
    const out = new Int16Array(float32.length);
    for (let i=0;i<float32.length;i++) {
      let s = Math.max(-1, Math.min(1, float32[i]));
      out[i] = s < 0 ? s * 32768 : s * 32767;
    }
    return out;
  }

  function downsampleBuffer(buffer, inRate, outRate) {
    if (outRate === inRate) return buffer;
    const ratio = inRate / outRate;
    const newLen = Math.round(buffer.length / ratio);
    const result = new Float32Array(newLen);
    let offsetResult = 0;
    let offsetBuffer = 0;
    while (offsetResult < result.length) {
      const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
      let sum = 0, count = 0;
      for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
        sum += buffer[i]; count++;
      }
      result[offsetResult] = sum / Math.max(1, count);
      offsetResult++; offsetBuffer = nextOffsetBuffer;
    }
    return result;
  }

  function packFrame(channelId, seq, pcm16) {
    const payload = new Uint8Array(pcm16.buffer);
    const buf = new ArrayBuffer(1 + 4 + payload.length);
    const view = new DataView(buf);
    view.setUint8(0, channelId);         // 2 => E
    view.setUint32(1, seq, true);
    new Uint8Array(buf, 5).set(payload);
    return buf;
  }

  function rms(buf){
    let s=0;
    for(let i=0;i<buf.length;i++){ const x=buf[i]; s+=x*x; }
    return Math.sqrt(s / Math.max(1, buf.length));
  }

  async function startElderMic() {
    if (!sessionId) return;

    // connect wsMic
    if (!wsMic || wsMic.readyState !== WebSocket.OPEN) {
      wsMic = new WebSocket(wsMicUrl());
      wsMic.binaryType = "arraybuffer";
      wsMic.onmessage = (ev) => {
        try {
          const data = JSON.parse(ev.data);
          if (data.type === "ping") wsMic.send(JSON.stringify({type:"pong", ts:data.ts}));
        } catch(e){}
      };
      await new Promise((res) => { wsMic.onopen = res; });
    }

    mediaStreamE = await navigator.mediaDevices.getUserMedia({
      audio: { channelCount: 1, echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    audioCtxE = new (window.AudioContext || window.webkitAudioContext)();
    const inRate = audioCtxE.sampleRate;

    sourceNodeE = audioCtxE.createMediaStreamSource(mediaStreamE);
    processorE = audioCtxE.createScriptProcessor(4096, 1, 1);

    processorE.onaudioprocess = (e) => {
      const ch = e.inputBuffer.getChannelData(0);

      // local visualize
      const v = Math.min(1.0, rms(ch) * 8.0);
      elWave.style.transform = `scaleY(${0.35 + v * 2})`;

      // send frames (push-to-talk)
      if (!elderStreaming) return;
      if (!wsMic || wsMic.readyState !== WebSocket.OPEN) return;

      const ds = downsampleBuffer(ch, inRate, targetRateE);
      const frameSize = 320; // 20ms @16k
      for (let i=0;i+frameSize<=ds.length;i+=frameSize) {
        const frame = ds.subarray(i, i+frameSize);
        const pcm = floatToPCM16(frame);
        const buf = packFrame(2, (seqE++ >>> 0), pcm);
        try { wsMic.send(buf); } catch(err) {}
      }
    };

    sourceNodeE.connect(processorE);
    processorE.connect(audioCtxE.destination);

    micReady = true;
    micBanner.style.display = "none";
    const btnTalk = document.getElementById("btnTalk");
    if (btnTalk) { btnTalk.disabled = false; btnTalk.textContent = "ğŸ™ï¸ å¼€å§‹æ”¶éŸ³"; }
    elderStreaming = false;
  }

  function stopElderMic() {
    micReady = false;
    elderStreaming = false;
    const btnTalk = document.getElementById("btnTalk");
    if (btnTalk) { btnTalk.disabled = true; btnTalk.textContent = "ğŸ™ï¸ å¼€å§‹æ”¶éŸ³"; }
    try { if (processorE) processorE.disconnect(); } catch(e){}
    try { if (sourceNodeE) sourceNodeE.disconnect(); } catch(e){}
    try { if (mediaStreamE) mediaStreamE.getTracks().forEach(t => t.stop()); } catch(e){}
    try { if (audioCtxE) audioCtxE.close(); } catch(e){}
    processorE = null; sourceNodeE = null; mediaStreamE = null; audioCtxE = null;

    try { if (wsMic) wsMic.close(); } catch(e){}
    wsMic = null;
  }

  async function ensureElderMic() {
    if (mode !== "live") return;
    if (micReady) return;
    try {
      await startElderMic();
    } catch (err) {
      // Most common reason: needs user gesture or permission denied
      micBanner.style.display = "block";
    }
  }

  btnEnableMic.onclick = async () => {
    try {
      await startElderMic();
    } catch (err) {
      alert("æ— æ³•å¯ç”¨éº¦å…‹é£ï¼š" + err);
    }
  };

  const btnTalk = document.getElementById("btnTalk");
  if (btnTalk) {
    btnTalk.onclick = () => {
      if (!micReady) { alert("è¯·å…ˆç‚¹å‡»â€œå¯ç”¨éº¦å…‹é£â€"); return; }
      elderStreaming = !elderStreaming;
      btnTalk.textContent = elderStreaming ? "â¹ï¸ åœæ­¢æ”¶éŸ³" : "ğŸ™ï¸ å¼€å§‹æ”¶éŸ³";
    };
  }


  // ---------- boot ----------
  (async function boot(){
    if (!sessionId) {
      await createNewSession();
    } else {
      renderJoinLinks();
      setMode("live");
      await refreshSessions();
      connectWS();
      ensureElderMic();
    }
    setPhase(phase);
  })();
</script>
</body>
</html>