<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>è€äººç«¯ï¼šSupporter-Agentï¼ˆç¨³å®šç‰ˆï¼‰</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#F8FAFC; margin:0; display:flex; height:100vh; color:#0F172A; }
    #sidebar { width:320px; background:#fff; border-right:1px solid #E2E8F0; padding:18px; box-sizing:border-box; overflow:auto; }
    #main { flex:1; display:flex; flex-direction:column; padding:18px; box-sizing:border-box; gap:12px; }
    .btn { background:#A78BFA; color:#fff; border:none; padding:10px 12px; border-radius:10px; cursor:pointer; font-size:15px; width:100%; }
    .btn.dark { background:#1E293B; }
    .btn.ghost { background:#fff; color:#0F172A; border:1px solid #E2E8F0; }
    .muted { color:#64748B; font-size:13px; }
    .row { display:flex; gap:10px; }
    .pill { padding:6px 10px; border-radius:999px; background:#E2E8F0; cursor:pointer; user-select:none; font-size:14px; }
    .pill.active { background:#A78BFA; color:#fff; }
    .card { background:#fff; border:1px solid #E2E8F0; border-radius:16px; box-shadow: 0 4px 10px -6px rgba(0,0,0,.12); min-height:0; }
    #chat { flex:1; padding:16px; overflow:auto; min-height:0; }
    .msg { display:flex; margin:10px 0; }
    .msg.right { justify-content:flex-end; }
    .bubble { max-width:75%; padding:10px 12px; border-radius:14px; line-height:1.5; font-size:15px; }
    .bubble.user { background:#A78BFA; color:#fff; border-bottom-right-radius:6px; }
    .bubble.other { background:#F1F5F9; color:#0F172A; border-bottom-left-radius:6px; }
    .meta { font-size:12px; opacity:.85; margin-bottom:4px; }
    #composer { display:flex; gap:10px; align-items:center; padding:12px; }
    #input { flex:1; padding:10px 12px; border:1px solid #E2E8F0; border-radius:12px; font-size:15px; outline:none; }
    .wave-box { height:66px; border-radius:40px; background:#F1F5F9; border:1px solid #E2E8F0; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .wave-bar { width:92%; height:34px; border-radius:20px; background: linear-gradient(90deg, #A78BFA, #C084FC, #A78BFA); transform: scaleY(.35); transition: transform .08s ease-out; }
    .session-item { padding:10px 10px; border-radius:12px; cursor:pointer; border:1px solid transparent; }
    .session-item:hover { background:#F8FAFC; border-color:#E2E8F0; }
    .session-item.active { background:#EEF2FF; border-color:#C7D2FE; }
    .divider { height:1px; background:#E2E8F0; margin:12px 0; }
    code { background:#F1F5F9; padding:1px 6px; border-radius:8px; }
  </style>
</head>
<body>
  <aside id="sidebar">
    <div class="row">
      <button class="btn" id="btnNew">â• å¼€å¯æ–°è®¨è®º</button>
    </div>
    <div style="margin-top:10px" class="muted">
      é‡‡é›†ç«¯åŠ å…¥é“¾æ¥ï¼ˆå•è®¾å¤‡åŒå£°é“ï¼‰ï¼š
      <div style="margin-top:6px; line-height:1.6">
        <code id="joinDual"></code>
      </div>
    </div>
    <div class="divider"></div>
    <div style="display:flex; align-items:center; justify-content:space-between">
      <b>ğŸ“œ å†å²ä¼šè¯</b>
      <span class="muted" id="modeBadge"></span>
    </div>
    <div id="sessionList" style="margin-top:10px"></div>
  </aside>

  <main id="main">
    <div class="row" style="gap:8px">
      <div class="pill" data-phase="preparation">è®¨è®ºå‰</div>
      <div class="pill active" data-phase="discussion">è®¨è®ºä¸­</div>
      <div class="pill" data-phase="review">è®¨è®ºå</div>
      <div style="flex:1"></div>
      <button class="btn ghost" id="btnToggleRecord" style="width:auto">ğŸ¤ æˆæƒé‡‡é›†ç«¯ï¼šå¼€</button>
      <button class="btn dark" id="btnEnd" style="width:auto">ç»“æŸè®¨è®ºå¹¶å­˜æ¡£</button>
    </div>

    <section class="card" style="flex:1; display:flex; flex-direction:column;">

<div style="display:flex; gap:10px; padding:12px 16px; border-bottom:1px solid #E2E8F0;">
  <div class="muted" id="capL" style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">è¯´è¯äºº1ï¼šâ€¦</div>
  <div class="muted" id="capR" style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; text-align:right;">â€¦ï¼šè¯´è¯äºº2</div>
</div>
      <div id="chat"></div>
      <div class="divider" style="margin:0"></div>
      <div id="composer">
        <input id="input" placeholder="è€äººè¯´ä¸€å¥â€¦ï¼ˆå›è½¦å‘é€ï¼‰"/>
        <button class="btn" id="btnSend" style="width:auto">å‘é€</button>
      </div>
    </section>

    <div class="muted">ğŸ™ï¸ è€äººç«¯éº¦å…‹é£ï¼ˆå®æ—¶éŸ³é‡ + è‡ªåŠ¨è½¬å†™ï¼‰</div>
    <div class="wave-box card"><div id="wave" class="wave-bar"></div></div>
  </main>

<script>
  // ---------- helpers ----------
  const qs = (k) => new URLSearchParams(location.search).get(k);
  const setQS = (k,v) => {
    const u = new URL(location.href);
    if (v === null) u.searchParams.delete(k); else u.searchParams.set(k,v);
    history.replaceState({}, "", u.toString());
  }
  const api = (path, opt={}) => fetch(path, {headers: {"Content-Type":"application/json"}, ...opt});
  const fmtTime = (unix) => {
    if(!unix) return "";
    const d = new Date(unix*1000);
    const pad = n => (n<10?("0"+n):n);
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  // ---------- state ----------
  let sessionId = qs("session_id");
  let phase = qs("phase") || "discussion";
  let mode = "live"; // live | view
  let lastMsgId = 0;
  let recordActive = true;
  let ws = null;
  let reconnectTimer = null;

let elderAudioWS = null;
let elderReconnectTimer = null;
let elderAudioCtx = null;
let elderMediaStream = null;
let elderSource = null;
let elderProcessor = null;
let elderSeq = 0;
const ELDER_TARGET_RATE = 16000;

function elderWsUrl() {
  const proto = location.protocol === "https:" ? "wss" : "ws";
  return `${proto}://${location.host}/ws/client?session_id=${encodeURIComponent(sessionId)}&channel=E`;
}

function connectElderAudioWS() {
  if (mode !== "live") return;
  if (!sessionId) return;
  if (elderAudioWS && (elderAudioWS.readyState === WebSocket.OPEN || elderAudioWS.readyState === WebSocket.CONNECTING)) return;

  elderAudioWS = new WebSocket(elderWsUrl());
  elderAudioWS.binaryType = "arraybuffer";

  elderAudioWS.onopen = () => { if (elderReconnectTimer) { clearTimeout(elderReconnectTimer); elderReconnectTimer=null; } };
  elderAudioWS.onclose = () => scheduleElderReconnect();
  elderAudioWS.onerror = () => scheduleElderReconnect();
  elderAudioWS.onmessage = () => {};
}

function scheduleElderReconnect() {
  if (mode !== "live") return;
  if (elderReconnectTimer) return;
  elderReconnectTimer = setTimeout(() => {
    elderReconnectTimer = null;
    connectElderAudioWS();
  }, 1200);
}

function floatToPCM16(float32) {
  const out = new Int16Array(float32.length);
  for (let i=0;i<float32.length;i++) {
    let s = Math.max(-1, Math.min(1, float32[i]));
    out[i] = s < 0 ? s * 32768 : s * 32767;
  }
  return out;
}

function downsampleBuffer(buffer, inRate, outRate) {
  if (outRate === inRate) return buffer;
  const ratio = inRate / outRate;
  const newLen = Math.round(buffer.length / ratio);
  const result = new Float32Array(newLen);
  let offsetResult = 0;
  let offsetBuffer = 0;
  while (offsetResult < result.length) {
    const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
    let sum = 0, count = 0;
    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
      sum += buffer[i];
      count++;
    }
    result[offsetResult] = sum / Math.max(1, count);
    offsetResult++;
    offsetBuffer = nextOffsetBuffer;
  }
  return result;
}

function packElderFrame(seq, pcm16) {
  const payload = new Uint8Array(pcm16.buffer);
  const buf = new ArrayBuffer(1 + 4 + payload.length);
  const view = new DataView(buf);
  view.setUint8(0, 2); // elder channel id
  view.setUint32(1, seq >>> 0, true);
  new Uint8Array(buf, 5).set(payload);
  return buf;
}

function rms(buf){
  let s=0;
  for(let i=0;i<buf.length;i++){ const x=buf[i]; s+=x*x; }
  return Math.sqrt(s / Math.max(1, buf.length));
}

async function startElderMicAuto() {
  if (mode !== "live") return;
  connectElderAudioWS();

  try {
    if (!elderMediaStream) {
      elderMediaStream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
      });
    }

    if (!elderAudioCtx) elderAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const inRate = elderAudioCtx.sampleRate;

    if (elderAudioCtx.state === "suspended") {
      // show a hint
      document.querySelector(".muted").textContent = "ğŸ™ï¸ éœ€è¦ä¸€æ¬¡ç‚¹å‡»ä»¥å¯ç”¨éº¦å…‹é£ï¼ˆç‚¹å‡»é¡µé¢ä»»æ„å¤„ï¼‰";
    }

    elderSource = elderAudioCtx.createMediaStreamSource(elderMediaStream);
    elderProcessor = elderAudioCtx.createScriptProcessor(4096, 1, 1);

    elderProcessor.onaudioprocess = (e) => {
      if (mode !== "live") return;
      const ch = e.inputBuffer.getChannelData(0);

      // local volume visualize
      const v = Math.min(1.0, rms(ch) * 8.0);
      elWave.style.transform = `scaleY(${0.35 + v * 2.2})`;

      if (!elderAudioWS || elderAudioWS.readyState !== WebSocket.OPEN) return;

      const ds = downsampleBuffer(ch, inRate, ELDER_TARGET_RATE);

      const frameSize = 320; // 20ms @16k
      for (let i=0;i+frameSize<=ds.length;i+=frameSize) {
        const frame = ds.subarray(i, i+frameSize);
        const pcm16 = floatToPCM16(frame);
        const buf = packElderFrame(elderSeq++, pcm16);
        try { elderAudioWS.send(buf); } catch(e) {}
      }
    };

    elderSource.connect(elderProcessor);
    elderProcessor.connect(elderAudioCtx.destination);

    const resume = async () => {
      try { if (elderAudioCtx && elderAudioCtx.state === "suspended") await elderAudioCtx.resume(); } catch(e) {}
      document.querySelector(".muted").textContent = "ğŸ™ï¸ è€äººç«¯éº¦å…‹é£ï¼ˆå®æ—¶éŸ³é‡ + è‡ªåŠ¨è½¬å†™ï¼‰";
    };
    document.addEventListener("click", resume, {once:true});

  } catch (err) {
    console.warn("Elder mic init failed:", err);
  }
}

function stopElderMic() {
  try { if (elderProcessor) elderProcessor.disconnect(); } catch(e){}
  try { if (elderSource) elderSource.disconnect(); } catch(e){}
  try { if (elderMediaStream) elderMediaStream.getTracks().forEach(t => t.stop()); } catch(e){}
  try { if (elderAudioCtx) elderAudioCtx.close(); } catch(e){}
  elderAudioCtx = null; elderMediaStream=null; elderSource=null; elderProcessor=null;
  elderSeq = 0;
  try { if (elderAudioWS) elderAudioWS.close(); } catch(e){}
  elderAudioWS = null;
}


  const elChat = document.getElementById("chat");
  const elInput = document.getElementById("input");
  const elWave = document.getElementById("wave");
  const elList = document.getElementById("sessionList");
  const elModeBadge = document.getElementById("modeBadge");
  const btnNew = document.getElementById("btnNew");
  const btnSend = document.getElementById("btnSend");
  const btnEnd = document.getElementById("btnEnd");
  const btnToggleRecord = document.getElementById("btnToggleRecord");
  const joinDual = document.getElementById("joinDual");

  function renderJoinLinks() {
    const base = `${location.protocol}//${location.host}`;
    joinDual.textContent = `${base}/client_display.html?session_id=${sessionId}`;
  }

  function setMode(newMode) {
    mode = newMode;
    elModeBadge.textContent = (mode === "view") ? "æŸ¥çœ‹æ¨¡å¼" : "å®æ—¶æ¨¡å¼";

    // è€äººç«¯ï¼šå®æ—¶æ¨¡å¼è‡ªåŠ¨é‡‡é›†ï¼›æŸ¥çœ‹æ¨¡å¼åœæ­¢é‡‡é›†ï¼ˆé¿å…ç¿»å†å²æ—¶å ç”¨éº¦ï¼‰
    if (mode === "live") {
      startElderMicAuto();
    } else {
      stopElderMic();
    }

    // In view mode: disable composer
    const disabled = (mode === "view");
    elInput.disabled = disabled;
    btnSend.disabled = disabled;
    btnToggleRecord.disabled = disabled;
    btnEnd.disabled = disabled;
    elInput.placeholder = disabled ? "å½“å‰ä¸ºæŸ¥çœ‹æ¨¡å¼ï¼Œç‚¹å‡»â€œå¼€å¯æ–°è®¨è®ºâ€è¿”å›å®æ—¶æ¨¡å¼" : "è€äººè¯´ä¸€å¥â€¦ï¼ˆå›è½¦å‘é€ï¼‰";
  }

  function setPhase(p) {
    phase = p;
    setQS("phase", p);
    document.querySelectorAll(".pill").forEach(x => x.classList.toggle("active", x.dataset.phase === p));
    // rerender from cache by filtering? simplest: reload view/live
    if (mode === "view") loadSessionView(sessionId);
  }

  document.querySelectorAll(".pill").forEach(p => p.addEventListener("click", () => setPhase(p.dataset.phase)));

  
function shouldAutoScroll() {
  // auto-scroll only when user is near bottom
  const threshold = 80;
  return (elChat.scrollHeight - (elChat.scrollTop + elChat.clientHeight)) < threshold;
}

function isNoiseText(t) {
  const s = String(t || "").trim();
  if (!s) return true;
  const low = s.toLowerCase().replaceAll(" ", "");
  const patterns = ["å­—å¹•by", "subtitlesby", "ç´¢å…°å¨…", "solanya", "solania"];
  for (const p of patterns) {
    if (low.includes(p.replaceAll(" ", "").toLowerCase())) return true;
  }
  // drop if all punct/symbol
  const allPunct = [...s].every(ch => {
    const isCJK = ch >= "\u4e00" && ch <= "\u9fff";
    const isNum = /[0-9]/.test(ch);
    const isAlpha = /[a-zA-Z]/.test(ch);
    return !(isCJK || isNum || isAlpha);
  });
  if (allPunct) return true;
  if (s.length < 2) return true;
  return false;
}

function addBubble(speaker, content, side, extraMeta="") {
  if (isNoiseText(content)) return;

  const auto = shouldAutoScroll();

  const wrap = document.createElement("div");
  wrap.className = "msg " + (side === "right" ? "right" : "left");
  const bubble = document.createElement("div");
  bubble.className = "bubble " + (side === "right" ? "user" : "other");
  bubble.innerHTML = `<div class="meta"><b>${speaker || ""}</b> ${extraMeta}</div>${escapeHtml(content)}`;
  wrap.appendChild(bubble);
  elChat.appendChild(wrap);

  if (auto) elChat.scrollTop = elChat.scrollHeight;
}

  function escapeHtml(str) {
    return String(str).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;").replaceAll("\n","<br/>");
  }

  function clearChat() { elChat.innerHTML = ""; lastMsgId = 0; }

  // ---------- WebSocket (robust reconnect) ----------
  function wsUrl() {
    const proto = location.protocol === "https:" ? "wss" : "ws";
    return `${proto}://${location.host}/ws/master?session_id=${encodeURIComponent(sessionId)}`;
  }

  function connectWS() {
    if (mode !== "live") return;
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

    ws = new WebSocket(wsUrl());

    ws.onopen = () => {
      if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
      // keepalive pong handler
      // also refresh join links
      renderJoinLinks();
    };

    ws.onmessage = (ev) => {
      const data = JSON.parse(ev.data);

      if (data.type === "ping") {
        ws.send(JSON.stringify({type:"pong", ts: data.ts}));
        return;
      }

      
if (data.type === "names") {
  // optional: show in UI later
  if (data.E) {
    // keep as "è€äºº" default; could extend UI if needed
  }
  return;
}

      if (data.type === "asr_partial") {
        const ch = (data.channel || "").toUpperCase();
        const t = data.content || "";
        if (ch === "L") document.getElementById("capL").textContent = `${data.speaker || "è¯´è¯äºº1"}ï¼š${t}`;
        if (ch === "R") document.getElementById("capR").textContent = `${data.speaker || "è¯´è¯äºº2"}ï¼š${t}`;
        return;
      }

      if (data.type === "text") {
        if (data.phase && data.phase !== phase) return; // show only current tab
        lastMsgId = Math.max(lastMsgId, data.id || 0);
        const side = (data.speaker === "è€äºº") ? "right" : "left";
        addBubble(data.speaker, data.content, side, `<span class="muted">${fmtTime(data.ts || 0)}</span>`);
        return;
      }

      if (data.type === "status") {
        // ignore for master
        return;
      }

      
if (data.type === "volume") {
  // æœåŠ¡å™¨æ¨é€éŸ³é‡ï¼ˆå« channel/valueï¼‰
  const ch = String(data.channel || "").toUpperCase();
  const v = data.value || 0;
  // è€äººç«¯çš„æ˜¾åŒ–ä¼˜å…ˆç”¨ E é€šé“ï¼›å¦‚æœåç«¯æ²¡å‘ Eï¼Œä¹Ÿå…è®¸ä»»æ„é€šé“é©±åŠ¨
  if (!ch || ch === "E") {
    elWave.style.transform = `scaleY(${0.35 + v * 2.2})`;
  }
  return;
}

    };

    ws.onclose = () => scheduleReconnect();
    ws.onerror = () => scheduleReconnect();
  }

  function scheduleReconnect() {
    if (mode !== "live") return;
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWS();
    }, 1200);
  }

  // ---------- REST: sessions ----------
  async function refreshSessions() {
    const res = await api("/api/sessions?limit=80");
    const data = await res.json();
    elList.innerHTML = "";
    (data.sessions || []).forEach(s => {
      const div = document.createElement("div");
      div.className = "session-item" + (s.session_id === sessionId && mode==="view" ? " active" : "");
      const title = s.summary_title || "ï¼ˆæœªå‘½åè®¨è®ºï¼‰";
      div.innerHTML = `<div><b>${escapeHtml(title)}</b></div><div class="muted">${fmtTime(s.created_at)}${s.ended_at ? " Â· å·²å­˜æ¡£" : ""}</div>`;
      div.onclick = () => openHistory(s.session_id);
      elList.appendChild(div);
    });
  }

  async function createNewSession() {
    const res = await api("/api/sessions", {method:"POST", body: JSON.stringify({meta:{}})});
    const s = await res.json();
    sessionId = s.session_id;
    setQS("session_id", sessionId);
    setMode("live");
    clearChat();
    renderJoinLinks();
    await refreshSessions();
    connectWS();
    startElderMicAuto();
  }

  async function endSession() {
    await api(`/api/sessions/${encodeURIComponent(sessionId)}/end`, {method:"POST", body: JSON.stringify({})});
    await refreshSessions();
    // keep live; user can start a new one explicitly
    alert("å·²å­˜æ¡£åˆ°å†å²ä¼šè¯ âœ…");
  }

  // ---------- view mode ----------
  async function openHistory(sid) {
    setMode("view");
    if (ws) { try { ws.close(); } catch(e) {} }
    sessionId = sid;
    setQS("session_id", sessionId);
    renderJoinLinks();
    await loadSessionView(sid);
    await refreshSessions();
  }

  async function loadSessionView(sid) {
    clearChat();
    const res = await api(`/api/sessions/${encodeURIComponent(sid)}`);
    const sess = await res.json();
    const msgs = (sess.messages || []).filter(m => m.phase === phase);

    msgs.forEach(m => {
      const side = (m.speaker === "è€äºº") ? "right" : "left";
      addBubble(m.speaker || "", m.content || "", side, `<span class="muted">${fmtTime(m.ts || 0)}</span>`);
      lastMsgId = Math.max(lastMsgId, m.id || 0);
    });
  }

  // ---------- send ----------
  async function sendText() {
    if (mode !== "live") return;
    const text = elInput.value.trim();
    if (!text) return;
    elInput.value = "";
    // push via WS for lowest latency
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type:"text", phase, speaker:"è€äºº", content:text}));
    } else {
      // fallback to REST (still will appear in view later)
      await api(`/api/sessions/${encodeURIComponent(sessionId)}/messages`, {method:"POST", body: JSON.stringify({
        phase, role:"user", speaker:"è€äºº", content:text
      })});
      addBubble("è€äºº", text, "right", `<span class="muted">${fmtTime(Math.floor(Date.now()/1000))}</span>`);
    }
  }

  btnSend.onclick = sendText;
  elInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendText(); });

  btnNew.onclick = async () => { await createNewSession(); };
  btnEnd.onclick = async () => { await endSession(); };

  btnToggleRecord.onclick = () => {
    recordActive = !recordActive;
    btnToggleRecord.textContent = `ğŸ¤ æˆæƒé‡‡é›†ç«¯ï¼š${recordActive ? "å¼€" : "å…³"}`;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type:"set_active", active: recordActive}));
    }
  }

  // ---------- boot ----------
  (async function boot(){
    // ensure session
    if (!sessionId) {
      await createNewSession();
    } else {
      renderJoinLinks();
      setMode("live");
      await refreshSessions();
      connectWS();
      startElderMicAuto();
    }
    setPhase(phase);
  })();
</script>
</body>
</html>
