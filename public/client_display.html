<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>é‡‡é›†ç«¯ï¼šRODE é‡‡é›†åŠ©æ‰‹ï¼ˆé˜¶æ®µé—¨æ§ç‰ˆï¼‰</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#F8FAFC; text-align:center; padding:40px; color:#0F172A;}
    .container { max-width: 860px; margin:0 auto; background:#fff; padding:28px; border-radius:20px; box-shadow:0 10px 15px -3px rgba(0,0,0,.1); }
    .name-row { display:flex; gap:16px; margin-bottom:22px; }
    .name-input { flex:1; text-align:left; }
    input { width:100%; padding:12px; border:1px solid #E2E8F0; border-radius:10px; font-size:16px; margin-top:6px; outline:none;}
    .wave-row { margin-bottom: 18px; text-align:left; }
    .wave-container { height: 90px; background:#F1F5F9; border-radius:15px; display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden; border:1px solid #E2E8F0; }
    .wave-bar { width:95%; height:46px; background: linear-gradient(90deg, #A78BFA, #818CF8, #A78BFA); border-radius:25px; transition: transform .05s ease-out; transform: scaleY(.25); }
    #status { padding: 14px; border-radius:10px; margin-top: 14px; font-weight:700; text-align:left; }
    .waiting { background:#FEF3C7; color:#92400E; }
    .active { background:#DCFCE7; color:#166534; }
    .off { background:#E2E8F0; color:#0F172A; }
    button { background:#A78BFA; color:#fff; border:none; padding:12px 18px; border-radius:10px; cursor:pointer; font-size:16px; width:100%; }
    .muted { color:#64748B; font-size:13px; margin-top:10px;}
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#EEF2FF; border:1px solid #C7D2FE; color:#3730A3; font-size:12px; margin-left:8px;}
  </style>
</head>
<body>
  <div class="container">
    <h1>é‡‡é›†ç«¯ï¼šRODE é‡‡é›†åŠ©æ‰‹ <span class="badge" id="phaseBadge">é˜¶æ®µï¼šè®¨è®ºä¸­</span></h1>
    <div class="muted" id="sidTip"></div>

    <div class="name-row">
      <div class="name-input">
        <label>è¯´è¯äºº1 (å·¦/L)ï¼š</label>
        <input type="text" id="nameL" value="å¥³å„¿">
      </div>
      <div class="name-input">
        <label>è¯´è¯äºº2 (å³/R)ï¼š</label>
        <input type="text" id="nameR" value="åŒ»ç”Ÿ">
      </div>
    </div>

    <div class="wave-row">
      <div id="labelL">ğŸ¤ å¥³å„¿</div>
      <div class="wave-container"><div id="waveL" class="wave-bar"></div></div>
    </div>

    <div class="wave-row">
      <div id="labelR">ğŸ¤ åŒ»ç”Ÿ</div>
      <div class="wave-container"><div id="waveR" class="wave-bar"></div></div>
    </div>

    <div class="name-row">
      <div class="name-input">
        <label>æµ‹è¯•æ–‡æœ¬å‘é€ï¼ˆä»…è°ƒè¯•ï¼‰ï¼š</label>
        <input type="text" id="textPayload" placeholder="è¾“å…¥è½¬å½•æ–‡æœ¬ï¼ˆä»…æµ‹è¯•ï¼‰">
      </div>
      <div class="name-input" style="display:flex; align-items:flex-end;">
        <div style="display:flex; gap:10px; width:100%">
          <button style="flex:1" onclick="sendText('L')">å‘é€ä¸ºè¯´è¯äºº1</button>
          <button style="flex:1" onclick="sendText('R')">å‘é€ä¸ºè¯´è¯äºº2</button>
        </div>
      </div>
    </div>

    <div id="status" class="waiting">ğŸ”´ ç­‰å¾…è€äººç«¯è¿›å…¥â€œè®¨è®ºä¸­â€å¹¶æˆæƒé‡‡é›†ç«¯...</div>

    <div class="muted" style="text-align:left;margin-top:12px">
      <b>åŒå£°é“é‡‡é›†ï¼š</b>ä»…åœ¨è€äººç«¯å¤„äº<strong>â€œè®¨è®ºä¸­â€</strong>é˜¶æ®µæ—¶æ‰ä¼šçœŸæ­£è¢«æ¥æ”¶å’Œè½¬å½•ã€‚
    </div>

    <div style="display:flex; gap:10px; margin-top:12px">
      <button id="btnStartAudio" style="flex:1">å¼€å§‹é‡‡é›†å¹¶ä¸Šä¼ éŸ³é¢‘</button>
      <button id="btnStopAudio" style="flex:1; background:#0F172A" disabled>åœæ­¢</button>
    </div>
  </div>

<script>
  // ----- params -----
  const params = new URLSearchParams(location.search);
  const sessionId = params.get("session_id") || "";
  document.getElementById("sidTip").textContent = sessionId ? `Session: ${sessionId} Â· Dual-Channel Mode` : "âš ï¸ ç¼ºå°‘ session_id å‚æ•°ï¼Œè¯·ä»è€äººç«¯å¤åˆ¶åŠ å…¥é“¾æ¥";

  // ----- state -----
  let ws = null;
  let reconnectTimer = null;

  let recordAuthorized = false;     // from master set_active
  let phaseNow = "discussion";      // from master set_phase
  let canStream = false;            // recordAuthorized && phaseNow === "discussion"

  function computeCanStream() {
    canStream = recordAuthorized && (phaseNow === "discussion");
    const s = document.getElementById("status");
    const badge = document.getElementById("phaseBadge");

    const phaseLabel = phaseNow === "preparation" ? "è®¨è®ºå‰" : (phaseNow === "review" ? "è®¨è®ºå" : "è®¨è®ºä¸­");
    badge.textContent = `é˜¶æ®µï¼š${phaseLabel}`;

    if (!recordAuthorized) {
      s.innerText = "ğŸŸ¡ é‡‡é›†ç«¯æœªæˆæƒï¼ˆè€äººç«¯å¯åˆ‡æ¢ï¼šæˆæƒé‡‡é›†ç«¯ï¼šå…³ï¼‰";
      s.className = "waiting";
    } else if (phaseNow !== "discussion") {
      s.innerText = `â¸ï¸ å½“å‰é˜¶æ®µä¸ºâ€œ${phaseLabel}â€ï¼Œé‡‡é›†ç«¯éŸ³é¢‘ä¸ä¼šè¢«æ¥æ”¶ï¼ˆä»…è®¨è®ºä¸­æ¥æ”¶ï¼‰`;
      s.className = "off";
    } else {
      s.innerText = "ğŸŸ¢ å·²æˆæƒä¸”å¤„äºâ€œè®¨è®ºä¸­â€ï¼Œæ­£åœ¨ä¼ è¾“å¹¶å‚ä¸è½¬å½•...";
      s.className = "active";
    }
  }

  // ----- ws -----
  function wsUrl() {
    const proto = location.protocol === "https:" ? "wss" : "ws";
    return `${proto}://${location.host}/ws/client?session_id=${encodeURIComponent(sessionId)}`;
  }

  function connectWS() {
    if (!sessionId) return;
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

    ws = new WebSocket(wsUrl());

    ws.onopen = () => {
      if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
      updateNames(true);
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === "ping") {
        ws.send(JSON.stringify({type:"pong", ts: data.ts}));
        return;
      }

      if (data.type === "phase") {
        phaseNow = String(data.phase || "discussion");
        if (!["preparation","discussion","review"].includes(phaseNow)) phaseNow = "discussion";
        computeCanStream();
        return;
      }

      if (data.type === "status") {
        recordAuthorized = !!data.active;
        if (data.phase) {
          phaseNow = String(data.phase);
          if (!["preparation","discussion","review"].includes(phaseNow)) phaseNow = "discussion";
        }
        computeCanStream();
        return;
      }

      if (data.type === "volume") {
        // compatible: new format {channel,value} or old {L,R}
        if (data.channel) {
          const ch = String(data.channel).toUpperCase();
          const v = data.value || 0;
          if (ch === "L") document.getElementById("waveL").style.transform = `scaleY(${0.2 + v * 2.5})`;
          if (ch === "R") document.getElementById("waveR").style.transform = `scaleY(${0.2 + v * 2.5})`;
        } else {
          document.getElementById("waveL").style.transform = `scaleY(${0.2 + (data.L||0) * 2.5})`;
          document.getElementById("waveR").style.transform = `scaleY(${0.2 + (data.R||0) * 2.5})`;
        }
        return;
      }
    };

    ws.onclose = () => scheduleReconnect();
    ws.onerror = () => scheduleReconnect();
  }

  function scheduleReconnect() {
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWS();
    }, 1200);
  }

  // ----- UI actions -----
  function updateNames(force=false) {
    const nL = document.getElementById('nameL').value;
    const nR = document.getElementById('nameR').value;
    document.getElementById('labelL').innerText = "ğŸ¤ " + nL;
    document.getElementById('labelR').innerText = "ğŸ¤ " + nR;

    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type:"names", L:nL, R:nR}));
    }
  }

  document.getElementById("nameL").addEventListener("change", () => updateNames(true));
  document.getElementById("nameR").addEventListener("change", () => updateNames(true));

  function sendText(which) {
    const payload = document.getElementById('textPayload').value.trim();
    if (!payload) return;
    const speaker = (which === "R") ? document.getElementById('nameR').value : document.getElementById('nameL').value;

    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type:"transcript", speaker, content: payload, phase:"discussion", channel: which}));
    }
    document.getElementById('textPayload').value = "";
  }

  // ----- Audio capture (stereo -> 2 mono 16k PCM16 frames) -----
  let audioCtx = null;
  let mediaStream = null;
  let sourceNode = null;
  let processor = null;
  let seqL = 0, seqR = 0;
  const targetRate = 16000;

  function floatToPCM16(float32) {
    const out = new Int16Array(float32.length);
    for (let i=0;i<float32.length;i++) {
      let s = Math.max(-1, Math.min(1, float32[i]));
      out[i] = s < 0 ? s * 32768 : s * 32767;
    }
    return out;
  }

  function downsampleBuffer(buffer, inRate, outRate) {
    if (outRate === inRate) return buffer;
    const ratio = inRate / outRate;
    const newLen = Math.round(buffer.length / ratio);
    const result = new Float32Array(newLen);
    let offsetResult = 0;
    let offsetBuffer = 0;
    while (offsetResult < result.length) {
      const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
      let sum = 0, count = 0;
      for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) { sum += buffer[i]; count++; }
      result[offsetResult] = sum / Math.max(1, count);
      offsetResult++; offsetBuffer = nextOffsetBuffer;
    }
    return result;
  }

  function packFrame(channelId, seq, pcm16) {
    const payload = new Uint8Array(pcm16.buffer);
    const buf = new ArrayBuffer(1 + 4 + payload.length);
    const view = new DataView(buf);
    view.setUint8(0, channelId);
    view.setUint32(1, seq, true);
    new Uint8Array(buf, 5).set(payload);
    return buf;
  }

  function rms(buf){
    let s=0;
    for(let i=0;i<buf.length;i++){ const x=buf[i]; s += x*x; }
    return Math.sqrt(s / Math.max(1, buf.length));
  }

  async function startAudio() {
    if (!sessionId) { alert("ç¼ºå°‘ session_id"); return; }
    if (!ws || ws.readyState !== WebSocket.OPEN) { alert("WS æœªè¿æ¥"); return; }

    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: { channelCount: { ideal: 2 }, echoCancellation:false, noiseSuppression:false, autoGainControl:false }
      });

      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const inRate = audioCtx.sampleRate;

      sourceNode = audioCtx.createMediaStreamSource(mediaStream);

      processor = audioCtx.createScriptProcessor(4096, 2, 2);

      processor.onaudioprocess = (e) => {
        // local visualize (always)
        const chL = e.inputBuffer.getChannelData(0);
        const chR = e.inputBuffer.numberOfChannels > 1 ? e.inputBuffer.getChannelData(1) : e.inputBuffer.getChannelData(0);

        const vL = Math.min(1.0, rms(chL) * 8.0);
        const vR = Math.min(1.0, rms(chR) * 8.0);
        document.getElementById("waveL").style.transform = `scaleY(${0.2 + vL * 2.5})`;
        document.getElementById("waveR").style.transform = `scaleY(${0.2 + vR * 2.5})`;

        // Only stream when authorized AND phase is discussion
        if (!canStream) return;

        const dsL = downsampleBuffer(chL, inRate, targetRate);
        const dsR = downsampleBuffer(chR, inRate, targetRate);

        const MAX_BUFFERED = 1_000_000; // 1MB
        if (ws && ws.bufferedAmount > MAX_BUFFERED) return;

        const frameSize = 320; // 20ms
        for (let i=0;i+frameSize<=dsL.length;i+=frameSize) {
          const frameL = dsL.subarray(i, i+frameSize);
          const frameR = dsR.subarray(i, i+frameSize);

          const pcmL = floatToPCM16(frameL);
          const pcmR = floatToPCM16(frameR);

          const bufL = packFrame(0, (seqL++ >>> 0), pcmL);
          const bufR = packFrame(1, (seqR++ >>> 0), pcmR);

          try { ws.send(bufL); } catch(err) {}
          try { ws.send(bufR); } catch(err) {}
        }
      };

      sourceNode.connect(processor);
      processor.connect(audioCtx.destination);

      document.getElementById("btnStartAudio").disabled = true;
      document.getElementById("btnStopAudio").disabled = false;
    } catch (err) {
      alert("æ— æ³•è·å–éº¦å…‹é£æƒé™æˆ–è®¾å¤‡ä¸å¯ç”¨ï¼š" + err);
    }
  }

  function stopAudio() {
    try { if (processor) processor.disconnect(); } catch(e){}
    try { if (sourceNode) sourceNode.disconnect(); } catch(e){}
    try { if (mediaStream) mediaStream.getTracks().forEach(t => t.stop()); } catch(e){}
    try { if (audioCtx) audioCtx.close(); } catch(e){}
    audioCtx = null; mediaStream = null; sourceNode = null; processor = null;
    document.getElementById("btnStartAudio").disabled = false;
    document.getElementById("btnStopAudio").disabled = true;
  }

  // ----- boot -----
  updateNames(false);
  computeCanStream();
  connectWS();
  document.getElementById("btnStartAudio").addEventListener("click", startAudio);
  document.getElementById("btnStopAudio").addEventListener("click", stopAudio);
</script>
</body>
</html>
